/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

import he from 'he';
import React from 'react';
import require$$0 from '@react-pdf/renderer';
import require$$0$1 from 'marked';

const headingSizes = [0, 32, 24, 18, 14, 12, 10]; // Inline styling

const strong = {
  fontWeight: "bold"
};
const em = {
  fontStyle: "italic"
};
const del = {
  textDecoration: "line-through"
};
const checkbox = {
  width: 10,
  height: 10
};
const codespan = {
  fontFamily: "Courier"
}; // Block styling

const block = {
  marginBottom: 16
};
const blockquote = {
  marginLeft: "4vw",
  ...block
};
const code = { ...codespan,
  ...block
};
const headings = [1, 2, 3, 4, 5, 6].reduce((headings, level) => ({ ...headings,
  [`h${level}`]: { ...block,
    fontSize: headingSizes[level]
  }
}), {});
const hr = { ...block,
  width: "50%",
  height: "1pt",
  backgroundColor: "black",
  marginLeft: "25%",
  marginRight: "25%"
};
const html = { ...block
};
const image = { ...block
};
const list = { ...block
};
const li = {
  display: "flex",
  flexDirection: "row",
  width: "100%"
};
const liPrefix = {
  width: "4vw",
  marginLeft: "2vw",
  marginRight: "2vw",
  textAlign: "right"
};
const liContent = {
  marginRight: "8vw"
};
const paragraph = { ...block
};
var styles = {
  strong,
  em,
  del,
  checkbox,
  codespan,
  blockquote,
  code,
  ...headings,
  hr,
  html,
  image,
  list,
  li,
  liPrefix,
  liContent,
  paragraph
};

const {
  Text,
  Link,
  View,
  Image,
  StyleSheet
} = require$$0;

var Renderer_1 = class Renderer {
  constructor(options) {
    this.options = options;
    this.key = 0;
    this.styles = StyleSheet.create(Object.assign(styles, options.styles || {}));
  } // Inline renderer


  text(text) {
    return /*#__PURE__*/React.createElement(Text, {
      key: `text-${this.key++}`
    }, he.decode(text));
  }

  checkbox(checked) {
    return /*#__PURE__*/React.createElement(Text, {
      key: `checkbox-${this.key}`,
      style: this.styles.checkbox
    }, checked ? "×" : "_");
  }

  br(key) {
    return /*#__PURE__*/React.createElement(Text, {
      key: `br-${this.key++}`
    }, "\\n");
  }

  strong(text) {
    return /*#__PURE__*/React.createElement(Text, {
      key: `strong-${this.key++}`,
      style: this.styles.strong
    }, text);
  }

  em(text) {
    return /*#__PURE__*/React.createElement(Text, {
      key: `em-${this.key++}`,
      style: this.styles.em
    }, text);
  }

  del(text) {
    return /*#__PURE__*/React.createElement(Text, {
      key: `del-${this.key++}`,
      style: this.styles.del
    }, text);
  }

  codespan(content) {
    return /*#__PURE__*/React.createElement(Text, {
      key: `codespan-${this.key++}`,
      style: this.styles.codespan
    }, content);
  }

  link(href, title, text) {
    return /*#__PURE__*/React.createElement(Link, {
      key: `br-${this.key++}`,
      src: href,
      title: title
    }, text);
  }

  // Blockquote
  blockquote(quote) {
    return /*#__PURE__*/React.createElement(View, {
      key: `blockquote-${this.key++}`,
      style: this.styles.blockquote
    }, /*#__PURE__*/React.createElement(Text, null, quote));
  }

  code(content, infostring, escaped) {
    return /*#__PURE__*/React.createElement(View, {
      key: `code-${this.key++}`,
      style: this.styles.code
    }, /*#__PURE__*/React.createElement(Text, null, content));
  }

  heading(text, level, raw, slugger) {
    const headingStyle = this.styles[`h${level}`];
    return /*#__PURE__*/React.createElement(View, {
      key: `h${level}-${this.key++}`,
      style: headingStyle
    }, text);
  }

  hr(key) {
    return /*#__PURE__*/React.createElement(View, {
      key: `hr-${this.key++}`,
      style: this.styles.hr
    });
  }

  html(html) {
    return html;
  }

  image(href, title, text) {
    return /*#__PURE__*/React.createElement(Image, {
      key: `image-${this.key++}`,
      style: this.styles.image,
      src: href
    });
  }

  list(body, ordered, start) {
    return /*#__PURE__*/React.createElement(View, {
      key: `list-${this.key++}`,
      style: this.styles.list
    }, body);
  }

  listitem(content, task, checked, ordered, index) {
    let liContent;
    const prefix = ordered ? `${index}.` : "• ";

    if (content.length > 1) {
      liContent = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Text, null, task && this.checkbox(checked), " ", content[0]), content.slice(1));
    } else {
      liContent = task ? /*#__PURE__*/React.createElement(Text, null, this.checkbox(checked), " ", content) : /*#__PURE__*/React.createElement(Text, null, content);
    }

    return /*#__PURE__*/React.createElement(View, {
      key: `li-${this.key++}`,
      style: this.styles.li
    }, /*#__PURE__*/React.createElement(Text, {
      style: this.styles.liPrefix
    }, prefix), /*#__PURE__*/React.createElement(View, {
      style: this.styles.liContent
    }, liContent));
  }

  paragraph(content) {
    return /*#__PURE__*/React.createElement(View, {
      key: `p-${this.key++}`,
      style: this.styles.paragraph
    }, /*#__PURE__*/React.createElement(Text, null, content));
  }

  table(header, body) {
    return body;
  }

  tablerow(content) {
    return content;
  }

  tablecell(content, flags) {
    return content;
  }

};

const {
  Slugger,
  defaults
} = require$$0$1;

var Parser_1 = class Parser {
  constructor(options) {
    this.options = options || defaults;
    this.options.renderer = new Renderer_1(this.options);
    this.renderer = this.options.renderer; // this.renderer.options = this.options;
    // this.textRenderer = new TextRenderer();

    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */


  static parse(tokens, options) {
    const parser = new Parser(options);
    return parser.parse(tokens);
  }
  /**
   * Parse Loop
   */


  parse(tokens, top = true) {
    const out = [];

    for (let i = 0; i < tokens.length; i++) {
      let token = tokens[i];

      switch (token.type) {
        case 'space':
          {
            continue;
          }

        case 'hr':
          {
            out.push(this.renderer.hr());
            continue;
          }

        case 'heading':
          {
            out.push(this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.renderer)), this.slugger));
            continue;
          }

        case 'code':
          {
            out.push(this.renderer.code(token.text, token.lang, token.escaped));
            continue;
          }

        case 'table':
          {
            // Table is unsupported
            continue;
          }

        case 'blockquote':
          {
            const body = this.parse(token.tokens);
            out.push(this.renderer.blockquote(body));
            continue;
          }

        case 'list':
          {
            const {
              ordered,
              start,
              loose,
              items
            } = token;
            const body = items.map((item, index) => {
              const {
                task,
                checked,
                tokens
              } = item;
              return this.renderer.listitem(this.parse(tokens, loose), task, checked, ordered, index + start);
            });
            out.push(this.renderer.list(body, ordered, start));
            continue;
          }

        case 'html':
          {
            out.push(this.renderer.html(token.text));
            continue;
          }

        case 'paragraph':
          {
            out.push(this.renderer.paragraph(this.parseInline(token.tokens)));
            continue;
          }

        case 'text':
          {
            const body = token.tokens ? this.parseInline(token.tokens) : token.text;

            while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
              token = tokens[++i];
              body.push(token.tokens ? this.parseInline(token.tokens) : token.text);
            }

            out.push(top ? this.renderer.paragraph(body) : body);
            continue;
          }

        default:
          {
            const errMsg = 'Token with "' + token.type + '" type was not found.';

            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
      }
    }

    return out;
  }
  /**
   * Parse Inline Tokens
   */


  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    const out = [];

    for (const token of tokens) {
      switch (token.type) {
        case 'escape':
          {
            out.push(renderer.text(token.text));
            break;
          }

        case 'html':
          {
            out.push(renderer.html(token.text));
            break;
          }

        case 'link':
          {
            out.push(renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer)));
            break;
          }

        case 'image':
          {
            out.push(renderer.image(token.href, token.title, token.text));
            break;
          }

        case 'strong':
          {
            out.push(renderer.strong(this.parseInline(token.tokens, renderer)));
            break;
          }

        case 'em':
          {
            out.push(renderer.em(this.parseInline(token.tokens, renderer)));
            break;
          }

        case 'codespan':
          {
            out.push(renderer.codespan(token.text));
            break;
          }

        case 'br':
          {
            out.push(renderer.br(i));
            break;
          }

        case 'del':
          {
            out.push(renderer.del(this.parseInline(token.tokens, renderer)));
            break;
          }

        case 'text':
          {
            out.push(renderer.text(token.text));
            break;
          }

        default:
          {
            const errMsg = 'Token with "' + token.type + '" type was not found.';

            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
      }
    }

    return out;
  }

};

const {
  lexer
} = require$$0$1;

var src = function (markdown, options) {
  const tokens = lexer(markdown);
  const parser = new Parser_1(options);
  return parser.parse(tokens);
};

export default src;
