/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global['marked-react-pdf'] = factory());
}(this, (function () { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var Renderer = require("./Renderer");

  var _require = require("marked"),
      Slugger = _require.Slugger,
      defaults = _require.defaults;

  module.exports = /*#__PURE__*/function () {
    function Parser(options) {
      _classCallCheck(this, Parser);

      this.options = options || defaults;
      this.options.renderer = new Renderer(this.options);
      this.renderer = this.options.renderer; // this.renderer.options = this.options;
      // this.textRenderer = new TextRenderer();

      this.slugger = new Slugger();
    }
    /**
     * Static Parse Method
     */


    _createClass(Parser, [{
      key: "parse",

      /**
       * Parse Loop
       */
      value: function parse(tokens) {
        var _this = this;

        var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var out = [];

        for (var _i = 0; _i < tokens.length; _i++) {
          var token = tokens[_i];

          switch (token.type) {
            case 'space':
              {
                continue;
              }

            case 'hr':
              {
                out.push(this.renderer.hr());
                continue;
              }

            case 'heading':
              {
                out.push(this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.renderer)), this.slugger));
                continue;
              }

            case 'code':
              {
                out.push(this.renderer.code(token.text, token.lang, token.escaped));
                continue;
              }

            case 'table':
              {
                // Table is unsupported
                continue;
              }

            case 'blockquote':
              {
                var body = this.parse(token.tokens);
                out.push(this.renderer.blockquote(body));
                continue;
              }

            case 'list':
              {
                var _ret = function () {
                  var _token = token,
                      ordered = _token.ordered,
                      start = _token.start,
                      loose = _token.loose,
                      items = _token.items;
                  var body = items.map(function (item, index) {
                    var task = item.task,
                        checked = item.checked,
                        tokens = item.tokens;
                    return _this.renderer.listitem(_this.parse(tokens, loose), task, checked, ordered, index + start);
                  });
                  out.push(_this.renderer.list(body, ordered, start));
                  return "continue";
                }();

                if (_ret === "continue") continue;
              }

            case 'html':
              {
                out.push(this.renderer.html(token.text));
                continue;
              }

            case 'paragraph':
              {
                out.push(this.renderer.paragraph(this.parseInline(token.tokens)));
                continue;
              }

            case 'text':
              {
                var _body = token.tokens ? this.parseInline(token.tokens) : token.text;

                while (_i + 1 < tokens.length && tokens[_i + 1].type === 'text') {
                  token = tokens[++_i];

                  _body.push(token.tokens ? this.parseInline(token.tokens) : token.text);
                }

                out.push(top ? this.renderer.paragraph(_body) : _body);
                continue;
              }

            default:
              {
                var errMsg = 'Token with "' + token.type + '" type was not found.';

                if (this.options.silent) {
                  console.error(errMsg);
                  return;
                } else {
                  throw new Error(errMsg);
                }
              }
          }
        }

        return out;
      }
      /**
       * Parse Inline Tokens
       */

    }, {
      key: "parseInline",
      value: function parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        var out = [];

        var _iterator = _createForOfIteratorHelper(tokens),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var token = _step.value;

            switch (token.type) {
              case 'escape':
                {
                  out.push(renderer.text(token.text));
                  break;
                }

              case 'html':
                {
                  out.push(renderer.html(token.text));
                  break;
                }

              case 'link':
                {
                  out.push(renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer)));
                  break;
                }

              case 'image':
                {
                  out.push(renderer.image(token.href, token.title, token.text));
                  break;
                }

              case 'strong':
                {
                  out.push(renderer.strong(this.parseInline(token.tokens, renderer)));
                  break;
                }

              case 'em':
                {
                  out.push(renderer.em(this.parseInline(token.tokens, renderer)));
                  break;
                }

              case 'codespan':
                {
                  out.push(renderer.codespan(token.text));
                  break;
                }

              case 'br':
                {
                  out.push(renderer.br(i));
                  break;
                }

              case 'del':
                {
                  out.push(renderer.del(this.parseInline(token.tokens, renderer)));
                  break;
                }

              case 'text':
                {
                  out.push(renderer.text(token.text));
                  break;
                }

              default:
                {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';

                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return out;
      }
    }], [{
      key: "parse",
      value: function parse(tokens, options) {
        var parser = new Parser(options);
        return parser.parse(tokens);
      }
    }]);

    return Parser;
  }();

  var Parser = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  var Lexer = require('./Lexer.js');

  var Parser$1 = require('./Parser.js');

  var Tokenizer = require('./Tokenizer.js');

  var Renderer$1 = require('./Renderer.js');

  var TextRenderer = require('./TextRenderer.js');

  var Slugger$1 = require('./Slugger.js');

  var _require$1 = require('./helpers.js'),
      merge = _require$1.merge,
      checkSanitizeDeprecation = _require$1.checkSanitizeDeprecation,
      escape = _require$1.escape;

  var _require2 = require('./defaults.js'),
      getDefaults = _require2.getDefaults,
      changeDefaults = _require2.changeDefaults,
      defaults$1 = _require2.defaults;
  /**
   * Marked
   */


  function marked(src, opt, callback) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    if (typeof opt === 'function') {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    if (callback) {
      var highlight = opt.highlight;
      var tokens;

      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      var done = function done(err) {
        var out;

        if (!err) {
          try {
            out = Parser$1.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
        }

        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;
      if (!tokens.length) return done();
      var pending = 0;
      marked.walkTokens(tokens, function (token) {
        if (token.type === 'code') {
          pending++;
          setTimeout(function () {
            highlight(token.text, token.lang, function (err, code) {
              if (err) {
                return done(err);
              }

              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }

              pending--;

              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });

      if (pending === 0) {
        done();
      }

      return;
    }

    try {
      var _tokens = Lexer.lex(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(_tokens, opt.walkTokens);
      }

      return Parser$1.parse(_tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  }
  /**
   * Options
   */


  marked.options = marked.setOptions = function (opt) {
    merge(marked.defaults, opt);
    changeDefaults(marked.defaults);
    return marked;
  };

  marked.getDefaults = getDefaults;
  marked.defaults = defaults$1;
  /**
   * Use Extension
   */

  marked.use = function (extension) {
    var opts = merge({}, extension);

    if (extension.renderer) {
      (function () {
        var renderer = marked.defaults.renderer || new Renderer$1();

        var _loop = function _loop(prop) {
          var prevRenderer = renderer[prop];

          renderer[prop] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var ret = extension.renderer[prop].apply(renderer, args);

            if (ret === false) {
              ret = prevRenderer.apply(renderer, args);
            }

            return ret;
          };
        };

        for (var prop in extension.renderer) {
          _loop(prop);
        }

        opts.renderer = renderer;
      })();
    }

    if (extension.tokenizer) {
      (function () {
        var tokenizer = marked.defaults.tokenizer || new Tokenizer();

        var _loop2 = function _loop2(prop) {
          var prevTokenizer = tokenizer[prop];

          tokenizer[prop] = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var ret = extension.tokenizer[prop].apply(tokenizer, args);

            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }

            return ret;
          };
        };

        for (var prop in extension.tokenizer) {
          _loop2(prop);
        }

        opts.tokenizer = tokenizer;
      })();
    }

    if (extension.walkTokens) {
      var walkTokens = marked.defaults.walkTokens;

      opts.walkTokens = function (token) {
        extension.walkTokens(token);

        if (walkTokens) {
          walkTokens(token);
        }
      };
    }

    marked.setOptions(opts);
  };
  /**
   * Run callback for every token
   */


  marked.walkTokens = function (tokens, callback) {
    var _iterator = _createForOfIteratorHelper(tokens),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var token = _step.value;
        callback(token);

        switch (token.type) {
          case 'table':
            {
              var _iterator2 = _createForOfIteratorHelper(token.tokens.header),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var cell = _step2.value;
                  marked.walkTokens(cell, callback);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              var _iterator3 = _createForOfIteratorHelper(token.tokens.cells),
                  _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var row = _step3.value;

                  var _iterator4 = _createForOfIteratorHelper(row),
                      _step4;

                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                      var _cell = _step4.value;
                      marked.walkTokens(_cell, callback);
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }

              break;
            }

          case 'list':
            {
              marked.walkTokens(token.items, callback);
              break;
            }

          default:
            {
              if (token.tokens) {
                marked.walkTokens(token.tokens, callback);
              }
            }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
  /**
   * Expose
   */


  marked.Parser = Parser$1;
  marked.parser = Parser$1.parse;
  marked.Renderer = Renderer$1;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.Tokenizer = Tokenizer;
  marked.Slugger = Slugger$1;
  marked.parse = marked;
  module.exports = marked;

  var marked$1 = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  var lexer = marked$1.lexer;

  var src = function (markdown, options) {
    var tokens = lexer(markdown);
    var parser = new Parser(options);
    return parser.parse(tokens);
  };

  return src;

})));
